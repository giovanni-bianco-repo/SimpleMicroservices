from datetime import datetime, timezone
from fastapi import APIRouter, HTTPException, Query
from typing import Dict, List, Optional
from uuid import UUID

from models.destination import DestinationRead, DestinationCreate, DestinationUpdate

router = APIRouter()

# In-memory "DB"
destinations: Dict[UUID, DestinationRead] = {}


@router.post("/destinations", response_model=DestinationRead, status_code=201)
def create_destination(destination: DestinationCreate) -> DestinationRead:
    """
    Create a new destination and add it to the in-memory database.
    ID/timestamps are generated by the server (DestinationRead defaults).
    """
    # Build the server-side model (generates id/created_at/updated_at)
    created = DestinationRead(**destination.model_dump())

    # Prevent accidental collisions (extremely unlikely with UUID4, but cheap to check)
    if created.id in destinations:
        raise HTTPException(
            status_code=400, detail="Generated ID collision; retry the request"
        )

    destinations[created.id] = created
    return created


@router.get("/destinations", response_model=List[DestinationRead])
def list_destinations(
    name: Optional[str] = Query(None, description="Filter by destination name"),
    country: Optional[str] = Query(None, description="Filter by country"),
    institution: Optional[str] = Query(None, description="Filter by institution"),
    continent: Optional[str] = Query(None, description="Filter by continent"),
) -> List[DestinationRead]:
    """
    List destinations, with optional filters.
    (Adjust filters to match your DestinationRead fields.)
    """
    results = list(destinations.values())

    if name is not None:
        # Assumes DestinationRead has a 'name' field
        results = [d for d in results if getattr(d, "name", None) == name]

    if country is not None:
        results = [d for d in results if getattr(d, "country", None) == country]

    if institution is not None:
        results = [d for d in results if getattr(d, "name", None) == institution]

    if continent is not None:
        results = [d for d in results if getattr(d, "continent", None) == continent]

    return results


@router.get("/destinations/{destination_id}", response_model=DestinationRead)
def get_destination(destination_id: UUID) -> DestinationRead:
    """Retrieve a destination by its UUID."""
    dest = destinations.get(destination_id)
    if dest is None:
        raise HTTPException(status_code=404, detail="Destination not found")
    return dest


@router.patch("/destinations/{destination_id}", response_model=DestinationRead)
def update_destination(
    destination_id: UUID, update: DestinationUpdate
) -> DestinationRead:
    """Update an existing destination by its UUID."""
    existing = destinations.get(destination_id)
    if existing is None:
        raise HTTPException(status_code=404, detail="Destination not found")

    # Start from stored dict, then apply only provided fields
    stored = existing.model_dump()
    stored.update(update.model_dump(exclude_unset=True))

    # Refresh updated_at
    stored["updated_at"] = datetime.now(timezone.utc)

    updated = DestinationRead(**stored)
    destinations[destination_id] = updated
    return updated


@router.delete("/destinations/{dest_id}", status_code=204)
def delete_destination(dest_id: str) -> None:
    """Delete a destination by its ID."""
    if dest_id not in destinations:
        raise HTTPException(status_code=404, detail="Destination not found")
    del destinations[dest_id]
